function [ E, A, conf_true ] = gen_network( gen_flag, N, c_given, epsilon, q, seed, basename, lcc )
% GEN_NETWORK generate a modular network
%  gen_flag, 
%   0: Generate by Block Model using SBM. To use this function you should install c++ program SBM 
%   1: Generate by Block Model using MATLAB code,
%   2: Random-Regular block network using MATLAB with rewiring,
%   3: Random-Regular block network using MATLAB with configuration model,
%   4: Read network and DEA matrix from files
%% generate a network
    assert(nargin==8);
    if(gen_flag==0) % Block Model using SBM
        cmd=sprintf('~/bin/sbm gen -n %d -P%g,%g -q%d -D%d --wall %s ',N,epsilon,c_given,q,seed,basename);
        fprintf(cmd);
        system(cmd);
        dprintf('loading E...\n')
        fname=sprintf('%s.spm',basename);
        E=importdata(fname)+1; %edge list
        A=E2A(E); %adjacency matrix
        fconf=sprintf('%s.conf',basename);
        conf_true=importdata(fconf)+1; %true configuration
    elseif(gen_flag==1) % Block Model using MATLAB code
        fprintf('Generating a network by Block Model with seed %d\n',seed);
        [E,A,conf_true]=gen_ran_modular(N,c_given,q,epsilon,seed);
    elseif(gen_flag==3 || gen_flag==2) % Random-Regular using MATLAB code, configuration model
        [E,A,conf_true]=gen_ran_rer_modular(N,c_given,q,epsilon,seed);
        fprintf('N=%d, M=%d\n',max(max(E)),length(E));
    elseif(gen_flag==4) % read basename
        dprintf('loading E...\n')
        fname=sprintf('%s.spm',basename);
        E=importdata(fname)+1; %edge list
        A=E2A(E); %adjacency matrix
        fconf=sprintf('%s.conf',basename);
        conf_true=importdata(fconf)+1; %true configuration
    elseif(gen_flag==5) % Random-Regular using MATLAB code, configuration model
        [E,A,conf_true]=gen_ran_rer_modular_2(N,c_given,q,epsilon,seed);
        fprintf('N=%d, M=%d\n',max(max(E)),length(E));
    end
    M=length(E);
%    N=max(max(E));
%    if(gen_flag ~= 4) % a check for generating of graphs
%        assert(N==N_);
%    end
    c=M/N*2.0;
    mystr=sprintf('c_given=%g, c=%g\n',c_given,c);
    dprintf(mystr);

    %% largest connected component
    if(lcc)
        %path(path,'./gaimc');
        disp('extracting larget connected component');
        if(gen_flag ==0  && gen_flag==0)
            fprintf('I can not extract LCC from network generated by SBM !!!\n');
            return
        end
        %fprintf('running on largest connected component\n');
        [A,pt]=largest_component(A);
        Nt=length(pt);%original size
        N=length(A);%size of largest connected component
        fprintf('original number of nodes: %d, number of nodes in LCC: %d\n',Nt,N);
        E=A2E(A);
        M=length(E);
        conf_true=conf_true(pt);
    end
    Q=max(conf_true);
    na=ones(1,Q)./Q;
    nad=zeros(1,Q);
    di=sum(A);
    for i=1:Q
        na(i)=sum(conf_true == i)/numel(conf_true);
        nad(i)=sum(di(conf_true == i))/sum(conf_true == i);
    end
    
    fprintf('network with N=%d, c=%g, q=%d, group sizes(in fraction) are:\n',N,c,Q);
    disp(na);
    fprintf('and average degree of groups are:\n');
    disp(nad);
end

